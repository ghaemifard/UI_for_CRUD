/*
 * generated by Xtext 2.10.0
 */
package edu.aut.islab.ghaemi.minuy.serializer;

import com.google.inject.Inject;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Accessory;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Aval;
import edu.aut.islab.ghaemi.minuy.myUiDsl.BackColor;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Body;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Border;
import edu.aut.islab.ghaemi.minuy.myUiDsl.BorderRad;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Bval;
import edu.aut.islab.ghaemi.minuy.myUiDsl.ClassName;
import edu.aut.islab.ghaemi.minuy.myUiDsl.ClassNameSec;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Clr;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Color;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Coord;
import edu.aut.islab.ghaemi.minuy.myUiDsl.CssStyles;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Disp;
import edu.aut.islab.ghaemi.minuy.myUiDsl.DownAspect;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Flt;
import edu.aut.islab.ghaemi.minuy.myUiDsl.FourAspect;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Gval;
import edu.aut.islab.ghaemi.minuy.myUiDsl.H8;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Head;
import edu.aut.islab.ghaemi.minuy.myUiDsl.InnerClass;
import edu.aut.islab.ghaemi.minuy.myUiDsl.InnerFeature;
import edu.aut.islab.ghaemi.minuy.myUiDsl.InnerStyle;
import edu.aut.islab.ghaemi.minuy.myUiDsl.InnerText;
import edu.aut.islab.ghaemi.minuy.myUiDsl.InnerType;
import edu.aut.islab.ghaemi.minuy.myUiDsl.LeftAspect;
import edu.aut.islab.ghaemi.minuy.myUiDsl.LiteralColor;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Marg;
import edu.aut.islab.ghaemi.minuy.myUiDsl.MaxVal;
import edu.aut.islab.ghaemi.minuy.myUiDsl.MidVal;
import edu.aut.islab.ghaemi.minuy.myUiDsl.MinMaxValue;
import edu.aut.islab.ghaemi.minuy.myUiDsl.MinVal;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Model;
import edu.aut.islab.ghaemi.minuy.myUiDsl.MyUiDslPackage;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Node;
import edu.aut.islab.ghaemi.minuy.myUiDsl.OFlow;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Padd;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Pos;
import edu.aut.islab.ghaemi.minuy.myUiDsl.RgbaColor;
import edu.aut.islab.ghaemi.minuy.myUiDsl.RightAspect;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Rval;
import edu.aut.islab.ghaemi.minuy.myUiDsl.SelfRepeat;
import edu.aut.islab.ghaemi.minuy.myUiDsl.UpAspect;
import edu.aut.islab.ghaemi.minuy.myUiDsl.VerAl;
import edu.aut.islab.ghaemi.minuy.myUiDsl.Wid;
import edu.aut.islab.ghaemi.minuy.services.MyUiDslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MyUiDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyUiDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyUiDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyUiDslPackage.ACCESSORY:
				sequence_Accessory(context, (Accessory) semanticObject); 
				return; 
			case MyUiDslPackage.AVAL:
				sequence_Aval(context, (Aval) semanticObject); 
				return; 
			case MyUiDslPackage.BACK_COLOR:
				sequence_BackColor(context, (BackColor) semanticObject); 
				return; 
			case MyUiDslPackage.BODY:
				sequence_Body(context, (Body) semanticObject); 
				return; 
			case MyUiDslPackage.BORDER:
				sequence_Border(context, (Border) semanticObject); 
				return; 
			case MyUiDslPackage.BORDER_RAD:
				sequence_BorderRad(context, (BorderRad) semanticObject); 
				return; 
			case MyUiDslPackage.BVAL:
				sequence_Bval(context, (Bval) semanticObject); 
				return; 
			case MyUiDslPackage.CLASS_NAME:
				sequence_ClassName(context, (ClassName) semanticObject); 
				return; 
			case MyUiDslPackage.CLASS_NAME_SEC:
				sequence_ClassNameSec(context, (ClassNameSec) semanticObject); 
				return; 
			case MyUiDslPackage.CLR:
				sequence_Clr(context, (Clr) semanticObject); 
				return; 
			case MyUiDslPackage.COLOR:
				sequence_Color(context, (Color) semanticObject); 
				return; 
			case MyUiDslPackage.COORD:
				sequence_Coord(context, (Coord) semanticObject); 
				return; 
			case MyUiDslPackage.CSS_STYLES:
				sequence_CssStyles(context, (CssStyles) semanticObject); 
				return; 
			case MyUiDslPackage.DISP:
				sequence_Disp(context, (Disp) semanticObject); 
				return; 
			case MyUiDslPackage.DOWN_ASPECT:
				sequence_DownAspect(context, (DownAspect) semanticObject); 
				return; 
			case MyUiDslPackage.FLT:
				sequence_Flt(context, (Flt) semanticObject); 
				return; 
			case MyUiDslPackage.FOUR_ASPECT:
				sequence_FourAspect(context, (FourAspect) semanticObject); 
				return; 
			case MyUiDslPackage.GVAL:
				sequence_Gval(context, (Gval) semanticObject); 
				return; 
			case MyUiDslPackage.H8:
				sequence_H8(context, (H8) semanticObject); 
				return; 
			case MyUiDslPackage.HEAD:
				sequence_Head(context, (Head) semanticObject); 
				return; 
			case MyUiDslPackage.INNER_CLASS:
				sequence_InnerClass(context, (InnerClass) semanticObject); 
				return; 
			case MyUiDslPackage.INNER_FEATURE:
				sequence_InnerFeature(context, (InnerFeature) semanticObject); 
				return; 
			case MyUiDslPackage.INNER_STYLE:
				sequence_InnerStyle(context, (InnerStyle) semanticObject); 
				return; 
			case MyUiDslPackage.INNER_TEXT:
				sequence_InnerText(context, (InnerText) semanticObject); 
				return; 
			case MyUiDslPackage.INNER_TYPE:
				sequence_InnerType(context, (InnerType) semanticObject); 
				return; 
			case MyUiDslPackage.LEFT_ASPECT:
				sequence_LeftAspect(context, (LeftAspect) semanticObject); 
				return; 
			case MyUiDslPackage.LITERAL_COLOR:
				sequence_LiteralColor(context, (LiteralColor) semanticObject); 
				return; 
			case MyUiDslPackage.MARG:
				sequence_Marg(context, (Marg) semanticObject); 
				return; 
			case MyUiDslPackage.MAX_VAL:
				sequence_MaxVal(context, (MaxVal) semanticObject); 
				return; 
			case MyUiDslPackage.MID_VAL:
				sequence_MidVal(context, (MidVal) semanticObject); 
				return; 
			case MyUiDslPackage.MIN_MAX_VALUE:
				sequence_MinMaxValue(context, (MinMaxValue) semanticObject); 
				return; 
			case MyUiDslPackage.MIN_VAL:
				sequence_MinVal(context, (MinVal) semanticObject); 
				return; 
			case MyUiDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MyUiDslPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case MyUiDslPackage.OFLOW:
				sequence_OFlow(context, (OFlow) semanticObject); 
				return; 
			case MyUiDslPackage.PADD:
				sequence_Padd(context, (Padd) semanticObject); 
				return; 
			case MyUiDslPackage.POS:
				sequence_Pos(context, (Pos) semanticObject); 
				return; 
			case MyUiDslPackage.RGBA_COLOR:
				sequence_RgbaColor(context, (RgbaColor) semanticObject); 
				return; 
			case MyUiDslPackage.RIGHT_ASPECT:
				sequence_RightAspect(context, (RightAspect) semanticObject); 
				return; 
			case MyUiDslPackage.RVAL:
				sequence_Rval(context, (Rval) semanticObject); 
				return; 
			case MyUiDslPackage.SELF_REPEAT:
				sequence_SelfRepeat(context, (SelfRepeat) semanticObject); 
				return; 
			case MyUiDslPackage.UP_ASPECT:
				sequence_UpAspect(context, (UpAspect) semanticObject); 
				return; 
			case MyUiDslPackage.VER_AL:
				sequence_VerAl(context, (VerAl) semanticObject); 
				return; 
			case MyUiDslPackage.WID:
				sequence_Wid(context, (Wid) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Accessory returns Accessory
	 *
	 * Constraint:
	 *     (left=Node (text=InnerText | style=InnerStyle | clazz=InnerClass | type=InnerType | feature=InnerFeature)*)
	 */
	protected void sequence_Accessory(ISerializationContext context, Accessory semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Aval returns Aval
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Aval(ISerializationContext context, Aval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.AVAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.AVAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAvalAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CssStyle returns BackColor
	 *     BackColor returns BackColor
	 *
	 * Constraint:
	 *     value=colorDef
	 */
	protected void sequence_BackColor(ISerializationContext context, BackColor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.BACK_COLOR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.BACK_COLOR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBackColorAccess().getValueColorDefParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Body returns Body
	 *
	 * Constraint:
	 *     (name=Node right+=Node+ selfRepeat=SelfRepeat?)
	 */
	protected void sequence_Body(ISerializationContext context, Body semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CssStyle returns BorderRad
	 *     BorderRad returns BorderRad
	 *
	 * Constraint:
	 *     (value=INT measureType=measureType?)
	 */
	protected void sequence_BorderRad(ISerializationContext context, BorderRad semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CssStyle returns Border
	 *     Border returns Border
	 *
	 * Constraint:
	 *     value=colorDef
	 */
	protected void sequence_Border(ISerializationContext context, Border semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.BORDER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.BORDER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBorderAccess().getValueColorDefParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Bval returns Bval
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Bval(ISerializationContext context, Bval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.BVAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.BVAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBvalAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassNameSec returns ClassNameSec
	 *
	 * Constraint:
	 *     cfClazz=ID
	 */
	protected void sequence_ClassNameSec(ISerializationContext context, ClassNameSec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.CLASS_NAME_SEC__CF_CLAZZ) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.CLASS_NAME_SEC__CF_CLAZZ));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassNameSecAccess().getCfClazzIDTerminalRuleCall_1_0(), semanticObject.getCfClazz());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassName returns ClassName
	 *
	 * Constraint:
	 *     ((theId=ID clazz+=ClassNameSec+) | clazz+=ClassNameSec+)?
	 */
	protected void sequence_ClassName(ISerializationContext context, ClassName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CssStyle returns Clr
	 *     Clr returns Clr
	 *
	 * Constraint:
	 *     value=ClrVals
	 */
	protected void sequence_Clr(ISerializationContext context, Clr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.CLR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.CLR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClrAccess().getValueClrValsEnumRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CssStyle returns Color
	 *     Color returns Color
	 *
	 * Constraint:
	 *     value=colorDef
	 */
	protected void sequence_Color(ISerializationContext context, Color semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.COLOR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.COLOR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColorAccess().getValueColorDefParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CssStyle returns Coord
	 *     Coord returns Coord
	 *
	 * Constraint:
	 *     value=FourAspect
	 */
	protected void sequence_Coord(ISerializationContext context, Coord semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.COORD__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.COORD__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCoordAccess().getValueFourAspectParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CssStyles returns CssStyles
	 *
	 * Constraint:
	 *     styles=CssStyle
	 */
	protected void sequence_CssStyles(ISerializationContext context, CssStyles semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.CSS_STYLES__STYLES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.CSS_STYLES__STYLES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCssStylesAccess().getStylesCssStyleParserRuleCall_0(), semanticObject.getStyles());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CssStyle returns Disp
	 *     Disp returns Disp
	 *
	 * Constraint:
	 *     value=DispVals
	 */
	protected void sequence_Disp(ISerializationContext context, Disp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.DISP__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.DISP__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDispAccess().getValueDispValsEnumRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DownAspect returns DownAspect
	 *
	 * Constraint:
	 *     (value=INT measureType=measureType?)
	 */
	protected void sequence_DownAspect(ISerializationContext context, DownAspect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CssStyle returns Flt
	 *     Flt returns Flt
	 *
	 * Constraint:
	 *     value=FltVals
	 */
	protected void sequence_Flt(ISerializationContext context, Flt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.FLT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.FLT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFltAccess().getValueFltValsEnumRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FourAspect returns FourAspect
	 *
	 * Constraint:
	 *     (left=LeftAspect | right=RightAspect | up=UpAspect | down=DownAspect)*
	 */
	protected void sequence_FourAspect(ISerializationContext context, FourAspect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Gval returns Gval
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Gval(ISerializationContext context, Gval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.GVAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.GVAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGvalAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CssStyle returns H8
	 *     H8 returns H8
	 *
	 * Constraint:
	 *     value=MinMaxValue
	 */
	protected void sequence_H8(ISerializationContext context, H8 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.H8__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.H8__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getH8Access().getValueMinMaxValueParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Head returns Head
	 *
	 * Constraint:
	 *     (fileName=ID headType=HeadType)
	 */
	protected void sequence_Head(ISerializationContext context, Head semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.HEAD__FILE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.HEAD__FILE_NAME));
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.HEAD__HEAD_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.HEAD__HEAD_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHeadAccess().getFileNameIDTerminalRuleCall_1_0(), semanticObject.getFileName());
		feeder.accept(grammarAccess.getHeadAccess().getHeadTypeHeadTypeParserRuleCall_3_0(), semanticObject.getHeadType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InnerClass returns InnerClass
	 *
	 * Constraint:
	 *     clazzes=ClassName
	 */
	protected void sequence_InnerClass(ISerializationContext context, InnerClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.INNER_CLASS__CLAZZES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.INNER_CLASS__CLAZZES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInnerClassAccess().getClazzesClassNameParserRuleCall_1_0(), semanticObject.getClazzes());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InnerFeature returns InnerFeature
	 *
	 * Constraint:
	 *     value=STRING2
	 */
	protected void sequence_InnerFeature(ISerializationContext context, InnerFeature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.INNER_FEATURE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.INNER_FEATURE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInnerFeatureAccess().getValueSTRING2TerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InnerStyle returns InnerStyle
	 *
	 * Constraint:
	 *     styles+=CssStyle*
	 */
	protected void sequence_InnerStyle(ISerializationContext context, InnerStyle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InnerText returns InnerText
	 *
	 * Constraint:
	 *     value=ID
	 */
	protected void sequence_InnerText(ISerializationContext context, InnerText semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.INNER_TEXT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.INNER_TEXT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInnerTextAccess().getValueIDTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InnerType returns InnerType
	 *
	 * Constraint:
	 *     value=InnerTypeArray
	 */
	protected void sequence_InnerType(ISerializationContext context, InnerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.INNER_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.INNER_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInnerTypeAccess().getValueInnerTypeArrayEnumRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LeftAspect returns LeftAspect
	 *
	 * Constraint:
	 *     (value=INT measureType=measureType?)
	 */
	protected void sequence_LeftAspect(ISerializationContext context, LeftAspect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     colorDef returns LiteralColor
	 *     LiteralColor returns LiteralColor
	 *
	 * Constraint:
	 *     (
	 *         value='Red' | 
	 *         value='Blue' | 
	 *         value='Black' | 
	 *         value='Green' | 
	 *         value='Yellow' | 
	 *         value='Pink' | 
	 *         value='Brown' | 
	 *         value='Gold' | 
	 *         value='White' | 
	 *         value='Grey'
	 *     )
	 */
	protected void sequence_LiteralColor(ISerializationContext context, LiteralColor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CssStyle returns Marg
	 *     Marg returns Marg
	 *
	 * Constraint:
	 *     value=FourAspect
	 */
	protected void sequence_Marg(ISerializationContext context, Marg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.MARG__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.MARG__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMargAccess().getValueFourAspectParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MaxVal returns MaxVal
	 *
	 * Constraint:
	 *     (value=INT measureType=measureType?)
	 */
	protected void sequence_MaxVal(ISerializationContext context, MaxVal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MidVal returns MidVal
	 *
	 * Constraint:
	 *     (value=INT measureType=measureType?)
	 */
	protected void sequence_MidVal(ISerializationContext context, MidVal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MinMaxValue returns MinMaxValue
	 *
	 * Constraint:
	 *     (minVal=MinVal | maxVal=MaxVal | midVal=MidVal)*
	 */
	protected void sequence_MinMaxValue(ISerializationContext context, MinMaxValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MinVal returns MinVal
	 *
	 * Constraint:
	 *     (value=INT measureType=measureType?)
	 */
	protected void sequence_MinVal(ISerializationContext context, MinVal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (heads+=Head* bodis+=Body+ accessories+=Accessory*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Node
	 *
	 * Constraint:
	 *     name=OneChar
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.NODE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.NODE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeAccess().getNameOneCharTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CssStyle returns OFlow
	 *     OFlow returns OFlow
	 *
	 * Constraint:
	 *     value=OFlowVals
	 */
	protected void sequence_OFlow(ISerializationContext context, OFlow semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.OFLOW__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.OFLOW__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOFlowAccess().getValueOFlowValsEnumRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CssStyle returns Padd
	 *     Padd returns Padd
	 *
	 * Constraint:
	 *     value=FourAspect
	 */
	protected void sequence_Padd(ISerializationContext context, Padd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.PADD__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.PADD__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPaddAccess().getValueFourAspectParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CssStyle returns Pos
	 *     Pos returns Pos
	 *
	 * Constraint:
	 *     value=PosVals
	 */
	protected void sequence_Pos(ISerializationContext context, Pos semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.POS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.POS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPosAccess().getValuePosValsEnumRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     colorDef returns RgbaColor
	 *     RgbaColor returns RgbaColor
	 *
	 * Constraint:
	 *     (rval=Rval | gval=Gval | bval=Bval | aval=Aval)+
	 */
	protected void sequence_RgbaColor(ISerializationContext context, RgbaColor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RightAspect returns RightAspect
	 *
	 * Constraint:
	 *     (value=INT measureType=measureType?)
	 */
	protected void sequence_RightAspect(ISerializationContext context, RightAspect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rval returns Rval
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Rval(ISerializationContext context, Rval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.RVAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.RVAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRvalAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SelfRepeat returns SelfRepeat
	 *
	 * Constraint:
	 *     (number=INT vertical?='*'?)
	 */
	protected void sequence_SelfRepeat(ISerializationContext context, SelfRepeat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UpAspect returns UpAspect
	 *
	 * Constraint:
	 *     (value=INT measureType=measureType?)
	 */
	protected void sequence_UpAspect(ISerializationContext context, UpAspect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CssStyle returns VerAl
	 *     VerAl returns VerAl
	 *
	 * Constraint:
	 *     value=VeralVals
	 */
	protected void sequence_VerAl(ISerializationContext context, VerAl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.VER_AL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.VER_AL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVerAlAccess().getValueVeralValsEnumRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CssStyle returns Wid
	 *     Wid returns Wid
	 *
	 * Constraint:
	 *     value=MinMaxValue
	 */
	protected void sequence_Wid(ISerializationContext context, Wid semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyUiDslPackage.Literals.WID__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyUiDslPackage.Literals.WID__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWidAccess().getValueMinMaxValueParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}
